package cmd

import (
	"fmt"
	"os"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/spf13/cobra"
)

// flagFrames holds the individual frames of the flag animation.
var flagFrames = []string{
	`╭────────╮
│ █▀▀▃▃▃ │
│ █▀▀▃▃█ │
│ █      │
╰────────╯`,
	`╭────────╮
│ █▀▀▀▃▃ │
│ █▀▀▀▃█ │
│ █      │
╰────────╯`,
	`╭────────╮
│ █▀▀▀▀▃ │
│ █▀▀▀▀█ │
│ █      │
╰────────╯`,
	`╭────────╮
│ █▃▀▀▀█ │
│ █▃▀▀▀█ │
│ █      │
╰────────╯`,
	`╭────────╮
│ █▃▃▀▀█ │
│ █▃▃▀▀▀ │
│ █      │
╰────────╯`,
	`╭────────╮
│ █▃▃▃▀█ │
│ █▃▃▃▀▀ │
│ █      │
╰────────╯`,
	`╭────────╮
│ █▃▃▃▃█ │
│ █▃▃▃▃▀ │
│ █      │
╰────────╯`,
	`╭────────╮
│ █▀▃▃▃▃ │
│ █▀▃▃▃█ │
│ █      │
╰────────╯`,
}

// primaryBg is the Lip Gloss style used to render the additional text.
var primaryBg = lipgloss.NewStyle().Foreground(lipgloss.ANSIColor(0)).Background(lipgloss.Color("226"))

// tickMsg is a message sent on each tick.
type tickMsg time.Time

// model defines the Bubble Tea model.
type model struct {
	frames       []string
	currentFrame int
	startTime    time.Time
	// text holds the additional text (if any) to be printed next to the flag.
	text string
}

// Init implements the Bubble Tea Model interface.
func (m model) Init() tea.Cmd {
	return tickCmd()
}

// Update is called when a message arrives.
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tickMsg:
		// Stop after 20 seconds.
		if time.Since(m.startTime) >= 20*time.Second {
			return m, tea.Quit
		}
		// Update the current frame.
		m.currentFrame = (m.currentFrame + 1) % len(m.frames)
		return m, tickCmd()
	case tea.KeyMsg:
		// Allow quitting early using "q" or Ctrl+C.
		switch msg.String() {
		case "q", "ctrl+c":
			return m, tea.Quit
		}
	}
	return m, nil
}

// View renders the current frame along with the additional text (if provided).
func (m model) View() string {
	// Get the current flag frame.
	flagView := primaryBg.Render(m.frames[m.currentFrame])
	// If no additional text was provided then simply display the flag.
	if m.text == "" {
		return flagView
	}

	// Render the additional text with style.
	styledText := primaryBg.Render(m.text)
	// Join the flag and the styled text next to each other.
	// A small horizontal margin is added between them.
	combined := lipgloss.JoinHorizontal(lipgloss.Top, flagView, "   "+styledText)
	return combined
}

// tickCmd returns a command that sends a tickMsg after 200ms.
func tickCmd() tea.Cmd {
	return tea.Tick(200*time.Millisecond, func(t time.Time) tea.Msg {
		return tickMsg(t)
	})
}

// --- Cobra command and main execution ---

var extraText string

// rootCmd is the root Cobra command.
var rootCmd = &cobra.Command{
	Use:   "flaganimator",
	Short: "Animates a flag with optional text",
	Run: func(cmd *cobra.Command, args []string) {
		// Inform the user that the animation is starting.
		fmt.Println("Flag animation starting...")
		// Create the Bubble Tea model.
		m := model{
			frames:       flagFrames,
			currentFrame: 0,
			startTime:    time.Now(),
			text:         extraText,
		}
		// Start the Bubble Tea program using Run() instead of Start().
		p := tea.NewProgram(m)
		if _, err := p.Run(); err != nil {
			fmt.Printf("Error running program: %v\n", err)
			os.Exit(1)
		}
		// When the program ends, print a final message.
		fmt.Println("Flag animation stopped")
	},
}

func init() {
	// Allow the user to specify additional text via --text or -t.
	rootCmd.PersistentFlags().StringVarP(
		&extraText,
		"text",
		"t",
		"",
		"Additional text to display next to the flag",
	)
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
